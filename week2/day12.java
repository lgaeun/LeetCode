class Solution {
    public int[] constructArray(int n, int k) {
        int[] ans = new int[n];
       
        // 내가 생각한 아이디어: k-1번 제일 큰수--, 제일작은수++를 번갈아 배열에 넣는다. then,마지막 차는 1 이니까 (k-1)+1=k개
        // 즉, [1,n,2,n-1,3,...] 처럼 배열에 큰수 작은수를 번갈아가며 넣으면 차는 |1-n|=k, |n-2|=k-1, |2-(n-1)|=k-2,.... =1 까지 k개가 된다
        // ex. (k=3,n=10): [1,10,2,3,4,5,6,7,8,9] 
        // ex. (k=4,n=10): [1,10,2,9,8,7,6,5,4,3]
      
        int a=1, z=n;
        for(int i = 0; i < k; i++) //(1)0~k-1번까지 수 채우기: 1을 처음에 넣고, 남은수 중 젤큰수 젤작은수를 k-1번만큼 번갈아 리스트에 넣는다
        	ans[i] = i%2==1 ? z-- : a++;
        //(2)k~(n-1)index까지 순서대로 채우기, 근데 홀수였으면 하나씩 증가 짝수였으면 하나씩 증가시 (so that 양옆수간의 차가 1로 경우가 1개뿐이 되므로)
        if(k%2==1)
            for(int i=k; i < n; i++) ans[i] = a++;
        else
            for(int i=k; i < n; i++) ans[i] = z--;
      
      
        //더 간단한 풀이 참고: k번째 수까지만을 이용해서 차가 k인수를 만든다 
        // ex) (k=3,n=10): [1,4,2,3,5,6,7,8,9,10]
        // ex. (k=4,n=10): [1,5,2,4,3,6,7,8,9,10]
      
         for(int i=0, a=1, z=k+1; i <= k; i++) //(1)0~k번까지는 n개의 남은수 중X, K까지의 숫자 중 젤큰수 작은수를 번갈아 넣는다
             ans[i] = i%2==1? z-- : a++;
         for(int i = k+1; i < n;)//(2)k+1~n까지는 다 증가만 하면 됌! 더 간단
             ans[i] = ++i;
        
        return ans;
    }
}
